{
    "author": "Anonymous Calc",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1063,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1063",
    "title": "2019w2 p5",
    "question": "I am a bit confused about how add-arrow works here. I\u2019m assuming that loc is the result of (rest (next-nodes n)), which is a list of nodes with counts that n points towards. My understanding for add-arrow is that it's doing something with the result of (first (next-nodes n)) and the result of (rest (next-nodes n)). However, it seems like they don't correspond to the n and loc parameters.\nCan someone explain what add-arrow does and provide an example if possible? Thank you in advance! f-p5-figure.pdf\n;; This is a generative graph problem. In this graph there are nodes,\n`;; represented by just a string, which is the node name.  Nodes have\n;; GENERATED links to 0 or more other nodes.  The function that generates\n;; the list of next nodes is called next-nodes, and WE ARE GIVING YOU\n;; THAT FUNCTION.  So, for example, in the graph shown in the attachment.\n;;\n;;   (next-nodes \u201cA\u201d)  produces  (list \u201cB\u201d \u201cC\u201d \u201cE\u201d)\n;;   (next-nodes \u201cB\u201d)  produces  (list \u201cA\u201d \u201cC\u201d \u201cD\u201d)\n;;\n;; You should only call next-nodes with the name of a node in the graph\n;; shown in the attachment, or with a node-name that next-nodes itself\n;; has produced.  But do not design your functions to only work with\n;; this graph, we may test it with other graphs. \n;;\n(@htdd Node)\n;; Node is String\n;; interp. a node with a name,\n;;         also next-nodes produces the nodes this node has arrows to\n(define NA \u201cA\u201d)\n(@htdd Count)\n(define-struct count (node in))\n;; Count is (make-count Node Natural)\n;; interp. a node and the number of arrows that point to it in a graph\n(define CA (make-count \u201cX\u201d 99))  ;99 arrows point to X (in some graph somewhere)\n;;\n;; Below you must complete the design of a function that consumes a Node and\n;; produces data representing the number of arrows that point at each node\n;; in the graph.\n;;\n;; For example:\n;;\n;;   (arrows \u201cA\u201d) could produce (list (make-count \u201cE\u201d 3)\n;;                                    (make-count \u201cC\u201d 2)\n;;                                    (make-count \u201cB\u201d 2)\n;;                                    (make-count \u201cD\u201d 2)\n;;                                    (make-count \u201cA\u201d 1))\n;;\n;; Note that the order of the result doesn\u2019t matter.  You are free to re-order\n;; the expected results in our check-expects below.\n;;\n;; Also note that this problem does not require compound worklist entries.\n;; You will not be penalized for using a compound WLE, but that is not required\n;; and it does not make the solution easier.\n;;\n(@htdf arrows)\n(@signature Node -> (listof Count))\n;; Produce counts of arrows going into each node.\n(check-expect (arrows \u201cA\u201d) (list (make-count \u201cE\u201d 3)\n                                 (make-count \u201cC\u201d 2)\n                                 (make-count \u201cB\u201d 2)\n                                 (make-count \u201cD\u201d 2)\n                                 (make-count \u201cA\u201d 1)))\n(check-expect (arrows \u201cB\u201d)  (list (make-count \u201cD\u201d 2)\n                                  (make-count \u201cC\u201d 2)\n                                  (make-count \u201cA\u201d 1)\n                                  (make-count \u201cE\u201d 3)\n                                  (make-count \u201cB\u201d 2)))\n(check-expect (arrows \u201cC\u201d) (list (make-count \u201cE\u201d 3)\n                                 (make-count \u201cD\u201d 2)\n                                 (make-count \u201cB\u201d 2)\n                                 (make-count \u201cC\u201d 2)\n                                 (make-count \u201cA\u201d 1)))\n(check-expect (arrows \u201cD\u201d) (list (make-count \u201cE\u201d 1)))\n(check-expect (arrows \u201cE\u201d) '())\n;; BELOW HERE IS SOLUTION\n(@template encapsulated\n           genrec arb-tree  ;graph\n           accumulator)\n(define (arrows n0)\n  ;; Termination:\n  ;;   base: todo is empty\n  ;;   reduction: if n not visited add its nexts to todo and add n to visited\n  ;;   argument:  todo grows only by nexts of n if not visited, graph is finite\n  ;;              so all nodes will eventually be visited\n \n  ;; visited is (listof String): all nodes already visited\n  ;; todo is (listof String): work list\n  ;; rsf is (listof (list String Natural)) : result so far\n  (local [(define (fn-for-n n todo visited rsf)\n            (cond [(member? n visited)\n                   (fn-for-lon todo visited rsf)]\n                  [else\n                   (fn-for-lon (append (next-nodes n) todo)\n                               (cons n visited)\n                               (foldr add-arrow rsf (next-nodes n)))])) \n          (define (fn-for-lon todo visited rsf)\n            (cond [(empty? todo) rsf]\n                  [else\n                   (fn-for-n (first todo) (rest todo) visited rsf)]))\n(define (add-arrow n loc)\n            (cond [(empty? loc) (list (make-count n 1))]\n                  [else\n                   (if (string=? (count-node (first loc)) n)\n                       (cons (make-count n (add1 (count-in (first loc))))\n                             (rest loc))\n                       (cons (first loc)\n                             (add-arrow n (rest loc))))]))]\n    \n    (fn-for-n n0 empty empty empty)))\n;;\n;; DO NOT READ PAST HERE.  THIS IS THE IMPLEMENTATION OF NEXT-NODES WE ARE\n;; GIVING YOU.  THERE\u2019S NOTHING ABOUT THIS THAT WILL HELP SOLVE THE PROBLEM\n;; YOU ARE ASKED TO SOLVE.\n;;\n(define GRAPH\n  '((\u201cA\u201d (\u201cB\u201d \u201cC\u201d \u201cE\u201d))\n    (\u201cB\u201d (\u201cA\u201d \u201cC\u201d \u201cD\u201d))\n    (\u201cC\u201d (\u201cB\u201d \u201cD\u201d \u201cE\u201d))\n    (\u201cD\u201d (\u201cE\u201d))\n    (\u201cE\u201d ())))\n(define (next-nodes n)\n  (cond [(not (string? n))\n         (error 'next-nodes (format \u201cNode name should be a string, not ~s.\u201d n))]\n        [(false? (assoc n GRAPH))\n         (error 'next-nodes (format \u201cNo node named ~s in graph.\u201d n))]\n        [else\n         (cadr (assoc n GRAPH))]))`",
    "student_answer": "from my understanding, the loc from add-arrow is (the result of the natural recursion passed through add-arrow) so it will be a (listof Count). If add-arrow doesn't find a Count whos count-node is equal to the node then it just makes one with a (list (make-count 1)) otherwise it will add1 to the integer value of Count or it will recurse through the rest until it either reaches the base case or finds a Count whos count-node is equal to the node.\nThe only reason I sort of understand this is because I was trying to do the same thing by mapping (add1 (count-in c)) onto the result of (filter pred rsf)) which I thought would work but map only consumes lists so ;( I will definitely be keeping this foldr solution in mind ",
    "instructor_answer": "Not Found"
}