{
    "author": "Ben Gao",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 957,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/957",
    "title": "clarification on searching trees",
    "question": "Just to double-check my understanding on how data in trees is traversed, is this understanding correct?\nAll functions operating on BSTs/ASTs using mutal recursion have the same \"Backtracking\", depth-first, the left to right pattern in traversing the data of the tree, no matter if it is an early problem like rendering the tree, backtracking search, generative recursion, tail recursion, etc. \nThat is, first traverse down the first, leftmost path of the tree all the way to the end (depth), and in the process, for structural recursion, essentially \"store\" immediate recursive calls for the rest of the children from each node traversed, in one big expression. and for tail recursion, use the worklist for the same thing.\nThen, after reaching the end, you start to executing the \"stored\" recursive calls, in the expression, starting with the recent stored recursive call, essentially \"backtracking\" to the nearest above node, and repeat the whole process, traverse down the leftmost path, generating the next immediate recursive calls for the rest of the children, and backtracking to the nearest node each time you reach an end or a set of children is exhausted. Moving left to right. And \"bottom to top\".\naccumulators also fit into this framework. As to why they don't store every single value traversed in total, it's because the accumulator in it's \"previous\" state is also stored in the recursive calls. So accumulators in structural recursion only stores the values traversed on the current path.\nFor tail recursion, perform the operation on the worklist in a similar fashion. Traverse the worklist, adding new items to the worklist, moving left to right.\nis this understanding correct?",
    "student_answer": "Not Found",
    "instructor_answer": "Yes that's exactly right.  In SR code it comes from the rules that make the templates, in particular look at the (listof X)\n(define (fn-for-lox lox)\n  (cond [(empty? lox) (...)]\n        [else\n          (... (fn-for-x (first lox))        ;go down the leftmost branch\n               (fn-for-lox (rest lox)))]))   ;then go across to the next branches\nIn tail recursive code it shows up in:\n         (fn-for-lox (append (node-subs x) x-wl) ...) ;this node's subs go before the parent's other kids"
}