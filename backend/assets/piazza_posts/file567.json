{
    "author": "Anonymous Helix",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 567,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/567",
    "title": "Module 7a practice problems",
    "question": "Hello, I am working on the merge starter in module 7a. After completing the problem I have realized my solution is very different but still seems to work. Is my solution all right?\nMY SOLUTION:\n(@htdf merge)\n(@signature ListOfNumber ListOfNumber -> ListOfNumber)\n;; produce new list of number with numbers sorted in ascending order\n;; CONSTRAINT: assume numbers in individual lists are already sorted\n(check-expect (merge empty empty) empty)\n(check-expect (merge empty (list 1)) (list 1))\n(check-expect (merge (list 2) empty) (list 2))\n(check-expect (merge (list 1) (list 2)) (list 1 2))\n(check-expect (merge (list 2) (list 1)) (list 1 2))\n(check-expect (merge (list 1 2) (list 3 4)) (list 1 2 3 4))\n(check-expect (merge (list 1 3) (list 2 4)) (list 1 2 3 4))\n(check-expect (merge (list 4 6) (list 5 7)) (list 4 5 6 7))\n;(define (merge lsta lstb) empty) ;stub\n(define (merge lsta lstb)\n  (cond [(empty? lstb) lsta]\n        [(empty? lsta) lstb]\n        [else (if (< (first lsta) (first lstb))\n                 (cons (first lsta)\n                       (insert (first lstb)\n                       (merge (rest lsta) (rest lstb))))\n                 (cons (first lstb)\n                       (insert (first lsta)\n                       (merge (rest lsta) (rest lstb)))))]))\n(@htdf insert)\n(@signature Number ListOfNumber -> ListOfNumber)\n;; produce new list of number based on inserting number into correct position in\n;; list\n;; CONSTRAINT: assume list is already sorted\n(check-expect (insert 1 empty) (list 1))\n(check-expect (insert 1 (list 2)) (list 1 2))\n(check-expect (insert 2 (list 1)) (list 1 2))\n(check-expect (insert 2 (list 1 2)) (list 1 2 2))\n(check-expect (insert 1 (list 1 2)) (list 1 1 2))\n(check-expect (insert 3 (list 2 4)) (list 2 3 4))\n;(define (insert n lon) empty)  ;stub\n(@template ListOfNumber)\n(define (insert n lon)\n  (cond [(empty? lon) (list n)]\n        [else\n         (if (< n (first lon))\n         (cons n lon)\n         (cons (first lon) (insert n (rest lon))))]))\nACTUAL SOLUTION:\n(define (merge l1 l2)\n  (cond [(empty? l1) l2]  ;(1)                 \n        [(empty? l2) l1]  ;(2)                  \n        [else             ;(3)                   \n         (if (<= (first l1) (first l2))\n             (cons (first l1)\n                   (merge (rest l1) l2))\n             (cons (first l2)\n                   (merge l1 (rest l2))))]))",
    "student_answer": "Not Found",
    "instructor_answer": "What template strategy are you using for merge?  there is no @template tag.  If it's 2-one-of, which is what it looks like, then please include a table if you want us to comment on a solution."
}