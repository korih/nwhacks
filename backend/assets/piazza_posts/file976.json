{
    "author": "Anonymous Atom",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 976,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/976",
    "title": "Maze problem",
    "question": "I am trying to redo the lecture problems and I attempted the maze problem but came to a slightly alternate solution to what was presented in lecture. It does not work currently (I am getting an error message saying : check-expect encountered the following error instead of the expected value, true. \n   :: length: expects a list, given 1 ) and I am not sure why. But other from that, I was wondering if there is anything flawed with my design?\nMy logic was that you could either have the maze being solved or run out of moves as the base case, and then from there you traverse the tree to basically search for those base cases. \n(@template arb-tree genrec try-catch encapsulated)\n(define (solvable? m) \n  ;; base: maze is in solved position or no more moves\n  ;; reduction: move right or down \n  ;; argument: maze is finite in size so repeated        ;; reduction eventually results in solved position    ;; or no more moves\n   \n  (local [(define (fn-for-pos p)\n            (cond [(and (= (sub1 (sqrt (length m)))                               (pos-x p))\n                        (= (sub1 (sqrt (length m)))                             (pos-y p))) true]\n                  [(and (false? (mref (+ 1 (pos-x p))                       (pos-y p))) (false? (mref (pos-x p) (mref (+ 1 (pos-y p)))))                                                 \n                   false]\n                  [else\n                   (fn-for-lop (valid-subs p))]))\n  \n\n          (define (fn-for-lop lop)\n            (cond [(empty? lop) false]\n                  [else \n                   (local [(define try (fn-for-pos                                   (first lop)))]\n                     (if (not (false? try))\n                         try\n                         (fn-for-lop (rest lop))))]))]\n    (fn-for-pos (make-pos 0 0))))\n\n(@htdf valid-subs)\n(@signature Position -> (listof Position))\n;; produce next possible positions given current position\n\n(define (valid-subs p)\n  (filter (lambda (x) (not (false? (mref x))))\n          (list (make-pos (+ 1 (pos-x p)) (pos-y p))\n                (make-pos (pos-x p) (+ 1 (pos-y p))))))\nAnd here are the check expects I have:\n(check-expect (solvable? M1) #t)\n(check-expect (solvable? M2) #t)\n(check-expect (solvable? M3) #t) \n(check-expect (solvable? M4) #f) \nAny feedback would be appreciated!",
    "student_answer": "Not Found",
    "instructor_answer": "look carefully at the arguments you are passing to mref"
}