{
    "author": "Anonymous Gear",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1011,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1011",
    "title": "nqueens question",
    "question": "this is coming from the nqueens problem bank question. can someone explain what exactly is going in these two functions? im really lost\n  ;; Board -> (listof Board)\n          ;; produce next valid boards by adding a queen at every position \n          ;; that does not attack an existing queen\n          ;; (@template fn-composition use-abstract-fn)\n          (define (next-boards bd)\n            (map (lambda (p2) (cons p2 bd))\n                 (filter (lambda (p2)\n                           (not-attacks-existing-queen? p2 bd))\n                         (build-list (sqr N) identity)))) ;all positions\n\n          (define (not-attacks-existing-queen? p bd)\n            (andmap (lambda (existing-queen)\n                      (not (attack? existing-queen p)))\n                    bd))\nThis is the entire function if needed:\n(define (nqueens N)          \n  ;; Termination argument:\n  ;; Trivial cases:\n  ;;   bd is solved or there are no valid next boards left to explore\n  ;; \n  ;; Reduction step:\n  ;;   (fn-for-lobd (next-boards bd)) in other words go explore the\n  ;;   valid next boards of this board\n  ;; \n  ;; Since board is finite, and each board is explored at most once, \n  ;; search will definitely terminate. (But the search space does grow\n  ;; really fast!)\n  \n  (local [;; Board -> Board or false\n          ;; do backtracking search of generated arb-arity tree of boards\n          (define (fn-for-bd bd)\n            (if (solved? bd)\n                bd\n                (fn-for-lobd (next-boards bd))))\n          \n          (define (fn-for-lobd lobd)\n            (cond [(empty? lobd) false]\n                  [else\n                   (local [(define try (fn-for-bd (first lobd)))]\n                     (if (not (false? try))\n                         try\n                         (fn-for-lobd (rest lobd))))]))\n          \n          \n          ;; Board -> Boolean\n          ;; Produce true if board has N queens.\n          ;; ASSUMPTION: Board is valid.\n          (define (solved? bd) (= (length bd) N))\n\n          \n          ;; Board -> (listof Board)\n          ;; produce next valid boards by adding a queen at every position \n          ;; that does not attack an existing queen\n          ;; (@template fn-composition use-abstract-fn)\n          (define (next-boards bd)\n            (map (lambda (p2) (cons p2 bd))\n                 (filter (lambda (p2)\n                           (not-attacks-existing-queen? p2 bd))\n                         (build-list (sqr N) identity)))) ;all positions\n\n          (define (not-attacks-existing-queen? p bd)\n            (andmap (lambda (existing-queen)\n                      (not (attack? existing-queen p)))\n                    bd))\n          \n          \n          ;; Board -> (listof Board)\n          ;; produce next valid boards by adding a queen at every new position \n          ;;   - comes after all existing queen positions (not required)\n          ;;   - does not attack any existing queens\n          ;; (@template encapsulated fn-composition use-abstract-fn)\n          ;(define (next-boards bd)\n          ;  (local [(define max-so-far (foldr max -1 bd))]       ;not required\n          ;            (map (lambda (p2) (cons p2 bd)) \n          ;                 (filter (lambda (p2)\n          ;                           (and (> p2 max-so-far)      ;not required\n          ;                                (andmap (lambda (p1)     \n          ;                                          (not (attack? p2 p1)))\n          ;                                        bd)))\n          ;                         (build-list (sqr N) identity)))))\n                    \n          \n          ;; Position Position -> Boolean\n          ;; produce true if queens at position a and b attack each other\n          (define (attack? pa pb)\n            (local [(define x1 (pos-x pa))\n                    (define y1 (pos-y pa))\n                    (define x2 (pos-x pb))\n                    (define y2 (pos-y pb))]\n              (or (= x1 x2)                           ;same row\n                  (= y1 y2)                           ;same column\n                  (= (/ (- y2 y1) (- x2 x1))  1)      ;same slope  1 diagonal\n                  (= (/ (- y2 y1) (- x2 x1)) -1))))   ;same slope -1 diagonal\n          \n          \n          ;; Pos -> Natural\n          ;; produce the row or column number in [0, N) for the given position\n          (define (pos-x p) (remainder p N))\n          (define (pos-y p) (quotient  p N))]\n    \n    (fn-for-bd empty)))",
    "student_answer": "To produce the next valid boards we need: \na. check that the position for the queen is valid and that there are no possible attacks\nb. create the board \nc. filter only the true positions (mentioned in (a))\nd. place the queens in those positions.",
    "instructor_answer": "Not Found"
}