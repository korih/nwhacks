{
    "author": "Anonymous Calc",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 871,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/871",
    "title": "count-odd-even problem",
    "question": "I was working on the below problem, and tried to write a normal, non-tail recursive function at first to solve it and then proceed from there, but I might have inadvertently arrived to a correct solution from there.\nCould anyone please give me some feedback/critique on what I might have done wrong here, or what could be improved? I think I understand tail-recursion and use of accumulators in the other problems I've practiced, but this one is confusing me a bit. I haven't written the examples/type/invariant for the accumulator yet as I'm still trying to make sense of my solution, how accumulators would come into play here, and how the function would be made tail-recursive. Greatly appreciate any help, thank you\n;; Previously we have written functions to count the number of elements in a\n;; list. In this problem we want a function that produces separate counts of the\n;; number of odd and even numbers in a list, and we only want to traverse the\n;; list once to produce that result.\n;;\n;; Design a tail recursive function that produces the Counts for a given list of\n;; numbers. Your function should produce Counts, as defined by the data\n;; definition below.\n;;\n;; There are two ways to code this function, one with 2 accumulators and one\n;; with a single accumulator. You should provide both solutions.\n\n\n(@htdd Counts)\n(define-struct counts (odds evens))\n;; Counts is (make-counts Natural Natural)\n;; interp. describes the number of even and odd numbers in a list\n\n(define C1 (make-counts 0 0)) ;describes an empty list\n(define C2 (make-counts 3 2)) ;describes (list 1 2 3 4 5))\n\n#;\n(define (fn-for-counts c)\n  (... (counts-odds c)\n       (counts-evens c)))\n\n(@htdf count-odd-even)\n(@signature (listof Natural) -> Counts)\n;; produce count of odd and even numbers in a list\n(check-expect (count-odd-even empty) (make-counts 0 0))\n(check-expect (count-odd-even (list 1)) (make-counts 1 0))\n(check-expect (count-odd-even (list 1 2)) (make-counts 1 1))\n(check-expect (count-odd-even (list 1 2 3 4 5)) (make-counts 3 2))\n\n;(define (count-odd-even lon) (make-counts 0 0))\n\n(@template (listof Natural))\n\n\n(define (count-odd-even lon0)\n  (local [(define (fn-for-count-odd-even c lon)\n            (cond [(empty? lon) c]\n                  [else\n                   (if (odd? (first lon))\n                       (fn-for-count-odd-even\n                        (make-counts (add1 (counts-odds c)) (counts-evens c))\n                        (rest lon))\n                       (fn-for-count-odd-even\n                        (make-counts (counts-odds c) (add1 (counts-evens c)))\n                        (rest lon)))]))]\n\n    (fn-for-count-odd-even (make-counts 0 0) lon0)))",
    "student_answer": "Maybe I'm not understanding something, but it looks to me like the counts is already the accumulator. (make-counts 0 0) in the initialization, [(empty? lon) c] is the use/exploit, and (add1 (counts-odds/evens c)) is the preserve.\nAlso, your function already looks tail-recursive.",
    "instructor_answer": "Your function is tail recursive.  And you chose to have an accumulator that was compound data with two fields.  Our solution just has two accumulators.  They are equivalent."
}