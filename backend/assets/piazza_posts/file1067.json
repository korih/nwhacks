{
    "author": "Anonymous Helix",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1067,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1067",
    "title": "2020 final q5",
    "question": "For this question, why should we use try-catch here?\n(@template Node (listof String) String genrec accumulator try-catch)\n#;\n;; SR solution\n(define (find-increasing-path start to) \n  (local [;; Termination argument:\n          ;;   trivial case: reach a node already on path\n          ;;   reduction: next nodes of current node\n          ;;   argument: graph is finite, so detecting cycles with path\n          ;;             will ensure that we eventually visit entire graph\n          ;;\n          ;; path is (listof String); names of nodes on this path in the graph\n          ;; prev is Natural; number of immediately prior node on this path\n          (define (find/node n path prev)\n            (cond;[(member (node-name n) path) false]  ;cycle                \n                  [(<= (node-num n) prev)       false] ;number must increase\n                  ;;                                   ;also prevents cycles\n                  [(string=? (node-name n) to)\n                   (reverse (cons (node-name n) path))]\n                  [else\n                   (find/loname (node-nexts n)\n                                (cons (node-name n) path)\n                                (node-num n))]))\n          \n          (define (find/loname lon path prev)\n            (cond [(empty? lon) false]\n                  [else\n                   (local [(define try (find/name  (first lon) path prev))]\n                     (if (not (false? try))\n                         try\n                         (find/loname (rest lon) path prev)))]))\n          \n          (define (find/name n path prev)\n            (find/node (lookup-node n) path prev))]\n\n    (find/name start empty 0)))",
    "student_answer": "The last statement in the questions instructions implies we use try-catch:\n;; Design a function that:\n;;   - is called find-increasing-path\n;;   - consumes the names of start and destination nodes\n;;   - tries to find a path from start to destination\n;;   - without passing through any node more than once\n;;   - and such that each node on the path has a number > than the prior\n;;     node\n;;   - if found it should produce a list of the names of the nodes in\n;;     order from start to destination for first path found\n;;   - otherwise it should fail",
    "instructor_answer": "Not Found"
}