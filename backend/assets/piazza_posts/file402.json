{
    "author": "Anonymous Gear",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 402,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/402",
    "title": "Helpers P2 - Making Rain Filtered",
    "question": "So the solution, I created for this program only used 6 functions because I created my own combination helper function for next-drops. Would this still be a proper application of Design recipes?\nThis is my solution to the problem:\n(@htdw ListOfDrop)\n\n;; =================\n;; Constants:\n\n(define WIDTH  300)\n(define HEIGHT 300)\n\n(define SPEED 1)\n\n(define DROP (ellipse 4 8 \"solid\" \"blue\"))\n\n(define MTS (rectangle WIDTH HEIGHT \"solid\" \"light blue\"))\n\n\n\n;; =================\n;; Data definitions:\n\n(@htdd Drop)\n(define-struct drop (x y))\n;; Drop is (make-drop Integer Integer)\n;; interp. a raindrop on the screen, with x and y coordinates in pixels.\n(define D1 (make-drop 10 30))\n\n(@dd-template-rules compound) ;2 fields\n\n#;\n(define (fn-for-drop d)\n  (... (drop-x d)       ;Integer\n       (drop-y d)))     ;Integer\n\n\n(@htdd ListOfDrop)\n;; ListOfDrop is one of:\n;;  - empty\n;;  - (cons Drop ListOfDrop)\n;; interp. a list of drops\n(define LOD1 empty)\n(define LOD2 (cons (make-drop 10 20) (cons (make-drop 3 6) empty)))\n\n(@dd-template-rules one-of             ;2 cases\n                    atomic-distinct    ;empty\n                    compound           ;(cons Drop ListOfDrop)\n                    ref                ;(first lod) is Drop\n                    self-ref)          ;(rest lod) is ListOfDrop\n\n#;\n(define (fn-for-lod lod)\n  (cond [(empty? lod) (...)]\n        [else\n         (... (fn-for-drop (first lod))\n              (fn-for-lod (rest lod)))]))\n\n\n\n;; =================\n;; Functions:\n\n(@htdf main)\n(@signature ListOfDrop -> ListOfDrop)\n;; start rain program by evaluating (main empty)\n\n(@template htdw-main)\n\n(define (main lod0)\n  (big-bang lod0                      ; ListOfDrop\n    (state true)\n    (on-mouse handle-mouse)   ; ListOfDrop Integer Integer\n    ; MouseEvent -> ListOfDrop\n    (on-tick  next-drops)     ; ListOfDrop -> ListOfDrop\n    (to-draw  render-drops))) ; ListOfDrop -> Image\n\n\n(@htdf handle-mouse)\n(@signature ListOfDrop Integer Integer MouseEvent -> ListOfDrop)\n;; if mevt is \"button-down\" add a new drop at that position\n(check-expect (handle-mouse empty (/ WIDTH 2) (/ HEIGHT 2) \"button-up\") empty)\n(check-expect (handle-mouse empty (/ WIDTH 2) (/ HEIGHT 2) \"button-down\")\n              (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2)) empty))\n(check-expect (handle-mouse (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2)) empty)\n                            (/ WIDTH 4) (/ HEIGHT 4) \"button-up\")\n              (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2)) empty))\n(check-expect (handle-mouse (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2)) empty)\n                            (/ WIDTH 4) (/ HEIGHT 4) \"button-down\")\n              (cons (make-drop (/ WIDTH 4) (/ HEIGHT 4))\n                    (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2)) empty)))\n(check-expect (handle-mouse (cons (make-drop (/ WIDTH 4) (/ HEIGHT 4))\n                                  (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2))\n                                        empty))\n                            (/ WIDTH 10) (/ HEIGHT 4) \"button-down\")\n              (cons (make-drop (/ WIDTH 10) (/ HEIGHT 4))\n                    (cons (make-drop (/ WIDTH 4) (/ HEIGHT 4))\n                          (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2)) empty))))\n;(define (handle-mouse lod x y mevt) empty) ;stub\n\n(@template MouseEvent)\n(define (handle-mouse lod x y mevt)\n  (cond [(mouse=? mevt \"button-down\") (cons (make-drop x y) lod)]\n        [else lod]))\n\n\n\n\n\n\n(@htdf next-drops)\n(@signature ListOfDrop -> ListOfDrop)\n;; produce filtered and ticked list of drops\n(check-expect (next-drops empty) empty)\n(check-expect (next-drops (cons (make-drop (/ WIDTH 4) (/ HEIGHT 2))\n                                (cons (make-drop (/ WIDTH 2) (/ HEIGHT 4))\n                                      empty)))\n              (cons (make-drop (/ WIDTH 4) (+ (/ HEIGHT 2) SPEED))\n                    (cons (make-drop (/ WIDTH 2) (+ (/ HEIGHT 4) SPEED))\n                          empty)))\n(check-expect (next-drops (cons (make-drop (/ WIDTH 4) HEIGHT)\n                                (cons (make-drop (/ WIDTH 2)\n                                                 (+ HEIGHT\n                                                    (/ (image-height DROP) 2)))\n                                      empty)))\n              (cons (make-drop (/ WIDTH 4) (+ HEIGHT SPEED))\n                    empty))\n(check-expect (next-drops (cons (make-drop (/ WIDTH 4) HEIGHT)\n                                (cons (make-drop\n                                       (/ WIDTH 2)\n                                       (- (+ HEIGHT\n                                             (/ (image-height DROP) 2)) 1))\n                                      empty)))\n              (cons (make-drop (/ WIDTH 4) (+ HEIGHT SPEED))\n                    (cons (make-drop (/ WIDTH 2) (+ HEIGHT\n                                                    (/ (image-height DROP) 2)))\n                          empty)))\n;(define (next-drops lod) empty) ;stub\n(@template ListOfDrop)\n(define (next-drops lod)\n  (cond [(empty? lod) empty]\n        [else\n         (cond-insert (next-drop (first lod))\n                      (next-drops (rest lod)))]))\n(@htdf cond-insert)\n(@signature Drop ListOfDrop -> ListOfDrop)\n;; insert the drop into list if drop can be on screen\n(check-expect (cond-insert (make-drop (/ WIDTH 2) (* HEIGHT 2)) empty) empty)\n(check-expect (cond-insert (make-drop (/ WIDTH 2) (/ HEIGHT 2)) empty)\n              (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2))empty))\n(check-expect (cond-insert (make-drop (/ WIDTH 4) (* HEIGHT 3))\n                           (cons (make-drop (/ WIDTH 4) (/ HEIGHT 2))\n                                 (cons (make-drop (/ WIDTH 2) (/ HEIGHT 4))\n                                       empty)))\n              (cons (make-drop (/ WIDTH 4) (/ HEIGHT 2))\n                    (cons (make-drop (/ WIDTH 2) (/ HEIGHT 4))\n                          empty)))\n(check-expect (cond-insert (make-drop (/ WIDTH 4) (/ HEIGHT 3))\n                           (cons (make-drop (/ WIDTH 4) (/ HEIGHT 2))\n                                 (cons (make-drop (/ WIDTH 2) (/ HEIGHT 4))\n                                       empty)))\n              (cons (make-drop (/ WIDTH 4) (/ HEIGHT 3))\n                    (cons (make-drop (/ WIDTH 4) (/ HEIGHT 2))\n                          (cons (make-drop (/ WIDTH 2) (/ HEIGHT 4))\n                                empty))))\n;(define (cond-insert d lod) lod);stub\n(@template Drop)\n(define (cond-insert d lod)\n  (if (> (drop-y d) (+ HEIGHT (/ (image-height DROP) 2)))\n      lod\n      (cons d lod)))\n\n(@htdf next-drop)\n(@signature Drop -> Drop)\n;; produce the coordinates of the drop after a tick\n(check-expect (next-drop (make-drop (/ WIDTH 2) (/ HEIGHT 2)))\n              (make-drop (/ WIDTH 2) (+ (/ HEIGHT 2) SPEED)))\n(check-expect (next-drop (make-drop (/ WIDTH 4) HEIGHT))\n              (make-drop (/ WIDTH 4) (+ HEIGHT SPEED)))\n;(define (next-drop d) d);stub\n(@template Drop)\n(define (next-drop d)\n  (make-drop (drop-x d) (+ (drop-y d) SPEED)))  \n\n(@htdf render-drops)\n(@signature ListOfDrop -> Image)\n;; render the drops onto MTS\n(check-expect (render-drops empty) MTS)\n(check-expect (render-drops (cons (make-drop (/ WIDTH 4) (/ HEIGHT 2))\n                                 (cons (make-drop (/ WIDTH 2) (/ HEIGHT 4))\n                                       empty)))\n              (place-image DROP\n                           (/ WIDTH 4)\n                           (/ HEIGHT 2)\n                           (place-image DROP\n                                        (/ WIDTH 2)\n                                        (/ HEIGHT 4)\n                                        MTS)))\n(check-expect (render-drops (cons (make-drop (/ WIDTH 10) (/ HEIGHT 5))\n                                 (cons (make-drop (/ WIDTH 5) (/ HEIGHT 10))\n                                       empty)))\n              (place-image DROP\n                           (/ WIDTH 10)\n                           (/ HEIGHT 5)\n                           (place-image DROP\n                                        (/ WIDTH 5)\n                                        (/ HEIGHT 10)\n                                        MTS)))\n                                        \n;(define (render-drops lod) MTS) ;stub\n\n(@template ListOfDrop)\n(define (render-drops lod)\n  (cond [(empty? lod) MTS]\n        [else\n         (place-image DROP\n                      (drop-x (first lod))\n                      (drop-y (first lod))\n                      (render-drops (rest lod)))]))",
    "student_answer": "Not Found",
    "instructor_answer": "That works, but it doesn't really follow 1 task per function. The problem is that cond-insert is concerned with both checking whether a drop is on the screen (1 task) and inserting it into the list if so (1 task).  \nThe approach in the solution separates the tasks somewhat better:\n- updating all the drops\n- updating 1 drop\n- filtering all drops for ones that are off screen\n- testing whether one drop is onscreen\nWe will see later in the course that separating the tasks that operate on lists from other tasks helps improve our code."
}