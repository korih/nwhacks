{
    "author": "Anonymous Gear",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 995,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/995",
    "title": "2020W2 final - question 5",
    "question": "My solution to this question varies quite a bit from the original posted solution, however both the given tests pass. Would it be an acceptable solution? The termination argument also differs for me because I assumed the base case is when the end node is found, so any comments on my termination arguments would also be appreciated. Thank you.\n(@htdf find-increasing-path) ;uncomment this line when you start\n(@signature String String -> (listof String) or false)\n;; find a path frm start to end node under given constraints or false otherwise\n;; CONSTRAINTS: can't pass any node more than once\n;;              each node has a number > than the previous node\n;;              produces in order from start to end node if found\n\n\n(check-expect (find-increasing-path \"A\" \"C\") (list \"A\" \"B\" \"C\"))\n(check-expect (find-increasing-path \"D\" \"I\") false)\n\n(@template accumulator genrec try-catch)\n\n\n; NO TAIL RECURSION\n(define (find-increasing-path start-node-name end-node-name)\n  ;; Termination argument:\n  ;; base case: end node name is found\n  ;; reduction: next nodes of current node\n  ;; argument: graph is finite\n  ;;\n  ;; path: (listof String), current path\n  ;; visited-nums: (listof Natural), numbers of visited nodes\n  (local [(define (fn-for-node n path visited-nums)\n            (cond [(member? (node-name n) path) false]\n                  [(<= (node-num n) (first visited-nums)) false]\n                  [else (fn-for-los (node-nexts n) (cons (node-name n) path) (cons (node-num n) visited-nums))]))\n          \n          (define (fn-for-los los path visited-nums)\n            (cond [(empty? los) false]\n                  [else\n                   (local [(define try (fn-for-string (first los) path visited-nums))]\n                     (if (not (false? try))\n                         try\n                         (fn-for-los (rest los) path visited-nums)))]))\n\n          (define (fn-for-string s path visited-nums)\n            (if (string=? s end-node-name)\n                (reverse (cons s path))\n                (fn-for-node (lookup-node s) path visited-nums)))\n          ]\n    \n          (fn-for-string start-node-name empty (list 0))))",
    "student_answer": "Not Found",
    "instructor_answer": "The one quibble I would have with your solution is the use of the word visited to describe a path in data like accumulator.  I would name your second accumulator path-nums.\nBut here's a question - how would you summarize the difference between your solution and ours? Writing that out would help you learn the most from the differences. Give it a try below and we can comment."
}