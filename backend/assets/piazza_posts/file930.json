{
    "author": "Rajan Sapkota",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 930,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/930",
    "title": "Maze Shortest Path Starter Correction",
    "question": "This is a follow up question regarding the correction Gregor mentioned after the lecture, stating that the cond to remove a cycle should be:\n(member p path)\ninstead of \n(member p visited)\ndue to a join occurring. Is it fair to assume that in general, all functions where joins are relevant (eg: for functions trying to output the SHORTEST path), the cond question for removing cycles would be (member p path) instead of (member p visited)?\nAre there instances where this is not the case, wherein the existence of joins are relevant to the purpose of the code, but (member p visited) is used instead? I assume not, considering what Gregor mentioned regarding having to keep looking to check if the path is shorter than the rsf.",
    "student_answer": "Not Found",
    "instructor_answer": "Good question.\nStart by assuming that you have functions for traversing a graph. In this graph the nodes have type X. Also assume it has these typical accumulators, all CORRECTLY implemented:\nx-wl  (listof X) primary worklist of X\npath-wl  (listof (listof String)) tandem worklist of paths to corresponding element of x-wl\nvisited  (listof String)\nAssume the usual constraint that all X have unique names so that path and visited can be in terms of the names.\nIn the usual way, the parameters to the fn-for-x function will be (x path x-wl path-wl visited).\nNow, inside the fn-for-x function\n(member x path) will detect whether we have already encountered x on this path THROUGH THE GRAPH. In other words it will detect a cycle.\n(member x visited) will detect cycles, but it will also detect whether we have already encountered x on a succession of calls through the tail recursion that is not actually a path in the data. The latter is a join. That's what joins are - places where there are two or more routes to an x, that are not on the same path in the graph.\nHaving set all that up.\nWhen traversing  a graph you just have to detect cycles and not go around them a second time.  Otherwise you are literally going in circles.\nIf you detect joins then you can avoid having the tail recursion visit some part of the graph twice. \nIf you want to find the first path, or the first path length, or the first path depth, or first of any path like thing then (member x visited), in other words detecting cycles and joins is fine.\nBut if you want to find all the paths, or path lengths, or ...; so that you can either produce them all or pick one of them, then you have to do (member p path). That will stop you from going in circles, but will still let you find all possible paths."
}