{
    "author": "Mina Chong",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 672,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/672",
    "title": "2020w1-mt2 when to include fn-composition?",
    "question": "Hello, just checking my understanding about when to include fn-composition in the @template tag.\nHere's part of the solution for 7c):\n(@template use-abstract-fn fn-composition)\n\n(define (set=? lst1 lst2)\n  (local [(define (in-lst1? n) (ormap (\u03bb (x) (= n x)) lst1))\n          (define (in-lst2? n) (ormap (\u03bb (x) (= n x)) lst2))]\n    (and (andmap in-lst1? lst2)\n         (andmap in-lst2? lst1))))\nIn this case, why exactly is it that fn-composition is included? Is it because andmap calls another function (predicate) to pass tests on items of lst2, or because ormap calls a function that's been abbreviated using lambda, or something else?\nAlso, here was my full solution for the problem, using a different built-in function:\n(@htdf set=?)\n(@signature (listof Number) (listof Number) -> Boolean)\n;; true if each number in lon1 is in lon2 and each number in lon2 is in lon1\n(check-expect (set=? (list 1 2 3 4) (list 4 2 3 1)) true)\n(check-expect (set=? (list 1 3 2 4) (list 4 3 1 2)) true)\n(check-expect (set=? (list 1 2 3 4) (list 4 4 2 3 1)) true)\n(check-expect (set=? (list 1 2 3 4) (list 4 2 3 6 1)) false)\n\n;(define (set=? lon1 lon2) false) ; stub\n\n(@template use-abstract-fn fn-composition)\n\n(define (set=? lon1 lon2)\n  (local [(define (in-lon2? n1)\n            (not (empty? (filter (lambda ( x) (= n1 x)) lon2))))\n          (define (in-lon1? n2)\n            (not (empty? (filter (lambda ( x) (= n2 x)) lon1))))]\n    (and (andmap in-lon2? lon1) (andmap in-lon1? lon2))))\nIt's a lot less clear for the reader, but would this still be okay in exam situations (i.e. if we don't use the exact same abstract functions as are intended and included in the solution, will we be docked marks?)? Thanks!",
    "student_answer": "Not Found",
    "instructor_answer": "Strictly speaking I wouldn't usually call this a fn-composition, or at least not a composition of abstract functions.\nThis function composes and with andmap. Since and is not recursive we wouldn't normally go so far as to call this a fn composition.  Normally we say fn composition when two or more recursive functions operate on arbitrary sized data in an arrangement like this:\n (fn1 (fn2 ...))"
}