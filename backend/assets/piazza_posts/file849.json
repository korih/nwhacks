{
    "author": "Anonymous Mouse",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 849,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/849",
    "title": "Clarify the definition of tail recursion",
    "question": "Hi, sorry for this dumb question but I can't get the exact idea of tail recursion.\nDoes it simply mean the function call for the very last part of the every single sequence like below...?\nCould you give me an example to compare differences btw non-tail recursion and tail recursion...?\n(fn-for-lox (rest lox)\n                               (cons (first lox) rsf))",
    "student_answer": "Oh sorry I should've googled before writing this post. I got from SOF! Thanks!",
    "instructor_answer": "Not a dumb question at all, thank you for asking it! (I'm still going to answer this in case other people are curious hahaha)\nWe are dealing with two pieces of terminology: Tail position and tail recursion. \nAn expression is in tail position if there is nothing else waiting to make use of the result of that expression, and the result of that expression is the final result that is produced.\nLet's consider this simple if expression:\n(if (zero? n)\n    \"pog we love zero\"\n    (sad-keep-going (sub1 n)))\nIs the expression (zero? n) in tail position?\nThe answer is no, because we don't produce the result of zero? (a Boolean), we instead use the result of zero? to determine whether or not we produce \"pog we love zero\" or (sad-keep-going (sub1 n)).\nIs the function call (sad-keep-going (sub1 n)) in tail position?\nYes, it is, because whatever (sad-keep-going (sub1 n)) produces, will be produced once the if expression evaluates (given that (zero? n) produces false).\nIf our if expression looked like this instead:\n(if (zero? n)\n    \"pog we love zero\"\n    (stay-sad (sad-keep-going (sub1 n))))\n(sad-keep-going (sub1 n)) would not be in tail position anymore, as the result of it gets passed to the function stay-sad, AKA another function is waiting to use the result of it to do something else. stay-sad is now in tail position though!\nA function is tail recursive when all of its recursive calls are in tail position. \nSo when we consider a function like:\n(define (all-zeros lon)\n  (cond [(empty? lon) empty]\n        [else (if (zero? (first lon))\n                  (cons (first lon)\n                        (all-zeros (rest lon))) ;(1)\n                  (all-zeros (rest lon)))]))   ;(2)\nThis function is not tail recursive, as one of its recursive calls (1) is not in tail position, cons is doing something with that result.\nIts second recursive call is in tail position though!\nWe can fix all-zeros to be tail recursive though:\n(define (all-zeros lon rsf)\n  (cond [(empty? lon) rsf]\n        [else (if (zero? (first lon))\n                  (all-zeros (rest lon) (cons (first lon) rsf)) ;(1)\n                  (all-zeros (rest lon) rsf))]))                        ;(2)\nNow all the recursive calls are in tail position, so our function is tail recursive now \ud83d\ude0a"
}