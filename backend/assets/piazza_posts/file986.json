{
    "author": "Angad Dhillon",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 986,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/986",
    "title": "2020 W1 Final Problem 2",
    "question": "My solution is totally different from the answer key, but all the tests still pass in it and I use accumulators, so would this also be fine? And is my solution tail recursive?\n;; Design a function called longest-sequence that consumes a list of integers\n;; and produces the longest sequence of consective integers that are each one\n;; larger than the previous integer.  All of the following are examples of\n;; sequences of consecutive integers:\n;;\n;;     (list 1 2 3 4)\n;;     (list 2)\n;;     empty\n;;     (list -5 -4)\n;;\n;; Your solution MUST BE TAIL-RECURSIVE.\n;; \n;; If there are multiple sequences of the same length in the input list, then\n;; you must produce the first one (the left-most one) in the list.\n;;\n;; For example:\n;;  (longest-sequence  (list 8 9 1 8 6 7))     must produce (list 8 9)\n;;  (longest-sequence (list 8 7 8 -3 -2 -1 5)) must produce (list -3 -2 -1)\n;;\n;; You MAY want to call length, and if so that is fine, but it is not required.\n;; You MAY also want to handle the empty list case in the trampoline.\n;;\n;; You must include all relevant design recipe elements.\n;;\n;; As always, a file that does not run or that produces errors when run will\n;; lose a significant number of marks.  A file with failing tests is much\n;; less bad.  Run your work often, so that you can check and fix errors as\n;; soon as they creep in.  Also be sure to run every time before you submit.\n;;\n(@htdf longest-sequence)\n(@signature (listof Integer) -> (listof Integer))   \n;; produce longest sequence of integers that are 1 larger than previous integer\n(check-expect (longest-sequence empty) empty)      \n(check-expect (longest-sequence  (list 8 9 1 8 6 7)) (list 8 9))\n(check-expect (longest-sequence (list 8 7 8 -3 -2 -1 5)) (list -3 -2 -1))\n(@template accumulator (listof X))\n(define (longest-sequence loi0)\n  ;; prev is Integer; previous integer in list\n  ;; rsf is (listof Integer); list of integers that are 1 bigger than previous \n  ;; greatest is (listof Integer); longest list of integers that are 1 bigger than previous \n  (local [(define (fn-for-loi loi prev rsf greatest)\n            (cond [(empty? loi) (reverse greatest)]\n                  [else\n                   (cond [(= (first loi) (add1 prev))\n                          (fn-for-loi (rest loi) (first loi)          \n                                      (cons (first loi) rsf) \n                                      (if (>= (length greatest)\n                                              (length (cons (first loi) rsf)))\n                                          greatest\n                                          (cons (first loi) rsf)))]\n                         [else \n                          (fn-for-loi (rest loi) (first loi)\n                                      (cons (first loi) empty) greatest)])]))] \n    (if (empty? loi0)\n        empty\n        (fn-for-loi loi0 -inf.0 empty empty))))     ",
    "student_answer": "Not Found",
    "instructor_answer": "That looks good. The only comment I would make is that rsf is perhaps not the best name for that accumulator.  It's more like the current sequence, and greatest is the best or longest sequence."
}