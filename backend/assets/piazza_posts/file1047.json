{
    "author": "Anonymous Atom",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1047,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1047",
    "title": "2020 W2 P5 - Converted to tail recursion, one test failing",
    "question": "I made a working version of this problem first as stated in the instructions and then attempted the tail recursive version. It mostly works, but fails on one test and I'm having trouble diagnosing the issue. Here's my code:\n\n\n\n(@htdf find-increasing-path) ;uncomment this line when you start\n(@signature String String -> (listof String) or false)\n;; produce path from start to dest w/ increasing node-numbers or false\n(check-expect (find-increasing-path \"A\" \"B\") (list \"A\" \"B\"))\n(check-expect (find-increasing-path \"C\" \"H\") false)\n(check-expect (find-increasing-path \"A\" \"G\") (list \"A\" \"D\" \"E\" \"F\" \"G\"))\n(check-expect (find-increasing-path \"B\" \"H\") false)\n(check-expect (find-increasing-path \"A\" \"D\") (list \"A\" \"D\"))\n\n;(define (find-increasing-path start-node-name dest-node-name) empty) ;stub\n\n(@template Node genrec try-catch accumulator)\n\n(define (find-increasing-path start-node-name dest-node-name)\n  ;; Termination argument:\n  ;;\n  ;; Trivial case: reach dest node or node to pass through has number >\n  ;; previous node\n  ;; Reduction step: move to next node, check if been there before (detect\n  ;; cycles), check if node-number > previous node-number\n  ;; Argument: moving to next node in finite graph while checking if we have\n  ;; been there before means we will eventually reach either the dest\n  ;; node or a node with number < previous node number\n  ;;\n  ;; node-wl is (listof Node); node worklist\n  ;;\n  ;; path-wl is (listof (listof Node)); path of nodes to each corresponding\n  ;; node in node-wl\n  ;; prev is Natural; previous node number\n  ;;\n  ;; path is (listof String); list of node names in the current path\n  ;;\n  ;; visited is (listof String); list of visited node names\n  (local [(define (fn-for-node n node-wl path-wl prev path visited)\n            (cond [(<= (node-num n) prev) (fn-for-los node-wl\n                                                      path-wl\n                                                      prev\n                                                      path\n                                                      visited)]\n                  [(member (node-name n) visited) (fn-for-los node-wl\n                                                              path-wl\n                                                              prev\n                                                              path\n                                                              visited)]\n                  [(string=? (node-name n) dest-node-name)\n                   (append path (list (node-name n)))]\n                  [else\n                   (fn-for-los (append (node-nexts n) node-wl)\n                               (append (make-list\n                                        (length (node-nexts n))\n                                        (append path\n                                                (list\n                                                 (node-name n))))\n                                       path-wl)\n                               (node-num n)\n                               (append path (list (node-name n)))\n                               (append visited (list node-name n)))]))\n\n          (define (fn-for-los node-wl path-wl prev path visited)\n            (cond [(empty? node-wl) false]\n                  [else\n                   (fn-for-string (first node-wl)\n                                  (rest node-wl)\n                                  (rest path-wl)\n                                  prev\n                                  path\n                                  visited)]))\n\n          (define (fn-for-string s node-wl path-wl prev path visited)\n            (fn-for-node (lookup-node s) node-wl path-wl prev path visited))]\n\n\n    (fn-for-string start-node-name empty empty -inf.0 empty empty)))",
    "student_answer": "You might find it helpful to have 2 tandem worklists in this case since you might want to preserve the node numbers you've seen so far in each path. So think about adding another tandem worklist that preserves node numbers seen in each path.\nAlso, think about whether the visited accumulator is needed in this case. In your fn-for-node function definition, your second Q/A pair:\n(member (node-name n) visited)\nThe visited accumulator does not account for the specific path you're currently on. You should check in your current path if you've seen the current node or not, not whether you've seen the current node before at all.",
    "instructor_answer": "Not Found"
}