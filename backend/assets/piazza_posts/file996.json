{
    "author": "Anonymous Helix",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 996,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/996",
    "title": "maze 4-way-path-length TR",
    "question": "I was working through this problem and I came up with a solution that looks a bit different than what the solution file has, though my solution does still seem to produce the correct answer.\nIs there anything that I should be changing about my solution? One thing I'm already suspecting is that\nI shouldn't have a \"path\" or \"path-wl\". I remember hearing that in tail-recursion you have visited but not path, and in structural recursion it's the other way around, but I'm not sure why. Would be grateful if someone could also clear that up for me!\nMY ANSWER\n;; p-wl is (listof Pos): position-worklost; unvisited subs of visited positions\n;; path-wl is (listof (listof Pos): path worklist\n;; path of positions seen so far for each sub-position of current node\n;; visited is (listof Pos): positions seen so far\n          (define (solve/p p p-wl path path-wl visited)\n            (cond [(solved? p) (length (cons p path))]\n                  [(member p visited) (solve/lop p-wl path-wl visited)]\n                  [else\n                   (solve/lop (append (next-ps p) p-wl)\n                              (append (map (lambda (x)\n                                             (append (list p) path))\n                                           (next-ps p)) \n                                      path-wl)\n                              (cons p visited))]))\n                             \n          (define (solve/lop p-wl path-wl visited)\n            (cond [(empty? p-wl) false]\n                  [else\n                   (solve/p (first p-wl) (rest p-wl)\n                            (first path-wl) (rest path-wl)\n                            visited)]))\n\n\nPOSTED SOLUTION \n(define (solve/p p c p-wl c-wl visited)\n            (cond [(solved? p) (add1 c)]\n                  [(member p visited) (solve/lop p-wl c-wl visited)]\n                  [else\n                   (solve/lop\n                    (append                    (next-ps p)            p-wl)\n                    (append (make-list (length (next-ps p)) (add1 c)) c-wl)\n                    (cons p visited))]))\n\n          (define (solve/lop p-wl c-wl visited)\n            (cond [(empty? p-wl) false]\n                  [else\n                   (solve/p (first p-wl)\n                            (first c-wl)\n                            (rest p-wl)\n                            (rest c-wl)\n                            visited)]))",
    "student_answer": "Not Found",
    "instructor_answer": "Your solution is mostly fine.\nBut nowhere do your invariants talk about the two worklists being tandem, the elements being in correspondence etc.\nIt's fine to have a path in a tandem worklist - that's the canonical use of tandem worklists.  But in our solution we just stored the path length in the tandem worklist to show that was possible too."
}