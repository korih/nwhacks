{
    "author": "Anonymous Beaker",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1043,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1043",
    "title": "Signature",
    "question": "Hi, \nCan someone please explain when we use X in the Signature of a fold function and when we use previously defined Data (such as Mole, Fruit etc.?)?\nOr specifically, why didn't Fruit in this signature?\nThanks :)\n(@htdd Arbre Fruit)\n(define-struct trey (a b c))\n;; Arbre is (make-trey String Integer Fruit)\n\n\n(define-struct pear (f o))\n;; Fruit is one of:\n;;  - false\n;;  - (make-pear Arbre Fruit)\n\n\n(@htdf fold-arbre)\n;; Enter your signature here:\n(@signature (String Integer Y -> X) (X Y -> Y) Y Arbre -> X)\n;; Abstract fold for Arbre\n\n;; check-expects intentionally omitted from this question\n\n(@template Arbre Fruit encapsulated)\n\n(define (fold-arbre c1 c2 b1 t)\n  (local [(define (fn-for-arbre t)     ; --> X\n            (c1 (trey-a t)\n                (trey-b t)\n                (fn-for-fruit (trey-c t))))\n\n          (define (fn-for-fruit fp)    ; --> Y\n            (cond [(false? fp) b1]\n                  [else\n                   (c2 (fn-for-arbre (pear-f fp))\n                       (fn-for-fruit (pear-o fp)))]))]\n\n    (fn-for-arbre t)))",
    "student_answer": "It's best to look at the inputs one at a time and decide what each of them are.\nFor this function, fold-arbre takes 4,  C1, C2, B1, and t.\nC1 and C2 are in combination position, and as they take a function, can hypothetically produce anything. For example you could define a local function that takes an arbre, a fruit, and produces an image of a pear, for c2.\nAs c1 and c2 can be different functions, they should have a different variable name (i.e X, and Y).\nb1 is the base case for your fn-for-fruit function. As a function should always produce the same result type (ignoring try-catch which we don't do in fold) b1 will have the same result as c2, i.e. Y.\nAt this point your signature looks like this:\n(... ... ... -> X) (... ... -> Y) Y ... -> ...\nAs the trampoline will return whatever type fn-for-arbre produces, we can fill in the last slot to be X, as well.\n(... ... ... -> X) (... ... -> Y) Y ... -> X\nNow where t is used in fn-for-arbre, it is clearly a trey, as we have the trey-selectors inside of fn-for-arbre. The data name for a trey structure is Arbre, so we fill that in as well.\n(... ... ... -> X) (... ... -> Y) Y Arbre -> X\nTo address the question of why fruit specifically is not in the signature, nothing that is an input of either function is a fruit, only fn-for-fruit.\nAs all you need to fill in now are the inputs for c1 and c2, you should be able to get them by referring the the data types and the previously defined function variables. If you have any questions or want me to work through the rest, let me know!",
    "instructor_answer": "Not Found"
}