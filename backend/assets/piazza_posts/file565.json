{
    "author": "Anonymous Beaker",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 565,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/565",
    "title": "Sinking Blobs Lab",
    "question": "When I run my program, all the blobs sink to the bottom. What the program was supposed to do, is sink the solid blob by one, rather than sink all the way to the bottom. \nI have two check-expects that guard against this happening (under (@htdf sink)) but I couldn't figure out how to get the function to do what I wanted. I commented them out just so I could get the program running, but my goal is to have a function that makes those check-expects work. \nI suspect my error is in my sink-one function, but I don't know what edit to make to it. It runs with (main empty) if you'd like to see :) Anything that could push me in the right direction would be very kind. \nThank you! (Note: this lab is over please don't delete my post guys)\n;; DATA DEFINITIONS ====================\n\n(@htdd Blob)\n;; Blob is one of:\n;; - \"solid\"\n;; - \"bubble\"\n;; interp.  a gelatinous blob, either a solid or a bubble\n;; Examples are redundant for enumerations\n\n(@dd-template-rules one-of atomic-distinct atomic-distinct)\n(define (fn-for-blob b)\n  (cond [(string=? b \"solid\") (...)]\n        [(string=? b \"bubble\") (...)]))\n\n\n(@htdd ListOfBlob)\n;; ListOfBlob is one of:\n;; - empty\n;; - (cons Blob ListOfBlob)\n;; interp. a sequence of blobs in a test tube, listed from top to bottom.\n(define LOB0 empty) ; empty test tube\n(define LOB2 (cons \"solid\" (cons \"bubble\" empty))) ; solid blob above a bubble\n\n(@dd-template-rules one-of atomic-distinct compound ref self-ref)\n(define (fn-for-lob lob)\n  (cond [(empty? lob) (...)]\n        [else\n         (... (fn-for-blob (first lob))\n              (fn-for-lob (rest lob)))]))\n\n\n;; FUNCTIONS ===========================\n\n(@htdf main)\n(@signature ListOfBlob -> ListOfBlob)\n;; start the world program with (main empty)\n\n(@template htdw-main)\n(define (main lob)\n  (big-bang lob\n    (to-draw render-lob)\n    (on-key  handle-key)))\n\n\n\n(@htdf render-lob)\n(@signature ListOfBlob -> Image)\n;; renders the list of blobs on MTS\n(check-expect (render-lob empty) MTS)\n(check-expect (render-lob (cons \"bubble\"\n                                (cons \"solid\"\n                                      (cons \"bubble\" empty))))\n              (overlay/align \"middle\" \"bottom\"\n                             (above BUBBLE SOLID BUBBLE)\n                             MTS))\n\n(@template fn-composition)\n(define (render-lob lob)\n  (overlay/align \"middle\" \"bottom\"\n                 (render-blobs lob)\n                 MTS))\n\n(@htdf render-blobs)\n(@signature ListOfBlob -> Image)\n;; renders the list of blobs in vertical line\n(check-expect (render-blobs empty) empty-image)\n(check-expect (render-blobs (cons \"bubble\" (cons \"solid\" (cons \"solid\" empty))))\n              (above BUBBLE SOLID SOLID))\n\n(@template ListOfBlob)\n(define (render-blobs lob)\n  (cond [(empty? lob) empty-image]\n        [else\n         (above (render-blob (first lob))\n                (render-blobs (rest lob)))]))\n\n(@htdf render-blob)\n(@signature Blob -> Image)\n;; produce the image for the given blob\n(check-expect (render-blob \"bubble\") BUBBLE)\n(check-expect (render-blob \"solid\") SOLID)\n\n(@template Blob)\n(define (render-blob b)\n  (cond [(string=? b \"solid\") SOLID]\n        [(string=? b \"bubble\") BUBBLE]))\n\n\n(@htdf handle-key)\n(@signature ListOfBlob KeyEvent -> ListOfBlob)\n;; add blobs on \"s\", \"b\" and sink on \" \"\n(check-expect (handle-key (cons \"bubble\" (cons \"solid\" empty)) \"s\")\n              (cons \"solid\" (cons \"bubble\" (cons \"solid\" empty))))\n(check-expect (handle-key (cons \"bubble\" empty) \"b\")\n              (cons \"bubble\" (cons \"bubble\" empty)))\n(check-expect (handle-key (cons \"solid\" (cons \"bubble\" empty)) \" \")\n              (cons \"bubble\" (cons \"solid\" empty)))\n\n(@template KeyEvent)\n(define (handle-key lob ke)\n  (cond [(key=? \"s\" ke) (cons \"solid\" lob)]\n        [(key=? \"b\" ke) (cons \"bubble\" lob)]\n        [(key=? \" \" ke) (sink lob)]\n        [else lob]))\n\n\n(@problem 2)\n(@htdf sink)\n(@signature ListOfBlob -> ListOfBlob)\n;; produce a list of blobs that sinks the given solid blobs by one\n; !!!\n(check-expect (sink empty) empty)\n(check-expect (sink (cons \"bubble\" (cons \"solid\" (cons \"bubble\" empty))))\n              (cons \"bubble\" (cons \"bubble\" (cons \"solid\" empty))))\n(check-expect (sink (cons \"solid\" (cons \"solid\" (cons \"bubble\" empty))))\n              (cons \"bubble\" (cons \"solid\" (cons \"solid\" empty))))\n;(check-expect (sink (cons \"solid\" (cons \"bubble\" (cons \"bubble\" empty))))\n;              (cons \"bubble\" (cons \"solid\" (cons \"bubble\" empty))))\n\n;; On-Ground Students:\n;; As PRE-LAB: Complete these three check-expects, then uncomment them.\n\n(check-expect (sink (cons \"solid\" (cons \"bubble\" (cons \"solid\" empty))))\n              (cons \"bubble\" (cons \"solid\" (cons \"solid\" empty))))\n(check-expect (sink (cons \"bubble\" (cons \"solid\" (cons \"solid\" empty))))\n              (cons \"bubble\" (cons \"solid\" (cons \"solid\" empty))))\n;(check-expect (sink (cons \"solid\"\n;                          (cons \"solid\"\n;                                (cons \"bubble\" (cons \"bubble\" empty)))))\n;              (cons \"bubble\"\n;                    (cons \"solid\"\n;                          (cons \"solid\" (cons \"bubble\" empty)))))\n\n;(define (sink lob) lob) ;stub\n\n(@template ListOfBlob)\n(define (sink lob)\n  (cond [(empty? lob) empty]\n        [else\n         (sink-one (first lob)\n                   (sink (rest lob)))]))\n\n(@htdf sink-one)\n(@signature Blob ListOfBlob -> ListOfBlob)\n;;sink the first blob by one if solid\n;(define (sink-one b lob) empty)\n\n(check-expect (sink-one \"solid\" empty) (cons \"solid\" empty))\n\n(check-expect (sink-one \"solid\" (cons \"bubble\" empty))\n              (cons \"bubble\" (cons \"solid\" empty)))\n\n(check-expect (sink-one \"solid\" (cons \"solid\" empty))\n              (cons \"solid\" (cons \"solid\" empty)))\n\n(check-expect (sink-one \"bubble\" (cons \"solid\" empty))\n              (cons \"bubble\" (cons \"solid\" empty)))\n                        \n\n(define (sink-one b lob)\n  (cond [(empty? lob) (cons b empty)]\n        [else\n         (if (will-sink? b (first lob))\n             (cons (first lob)\n                   (sink-one b\n                          (rest lob)))\n             (cons b lob))]))\n\n\n(@htdf will-sink?)\n(@signature Blob Blob -> Boolean)\n;; consumes two blobs, produce true if the first blob is \"solid\"\n;(define (will-sink? b1 b2) false)\n\n(check-expect (will-sink? \"solid\" \"bubble\") true)\n(check-expect (will-sink? \"solid\" \"solid\") true)\n(check-expect (will-sink? \"bubble\" \"solid\") false)\n(check-expect (will-sink? \"bubble\" \"bubble\") false)\n\n(@template Blob)\n\n (define (will-sink? b1 b2)\n  (cond [(string=? b1 \"solid\") true]\n        [(string=? b1 \"bubble\") false]))\n\n\n(@htdf solid?)\n(@signature Blob -> Boolean)\n;; determine whether the blob is a solid or a bubble, true if solid.\n; (define (solid? blo) false) ;stub\n\n(check-expect (solid? \"bubble\") false)\n(check-expect (solid? \"solid\") true)\n\n(@template Blob)\n(define (solid? blo)\n  (cond [(string=? blo \"solid\") true]\n        [(string=? blo \"bubble\") false]))",
    "student_answer": "(define (sink-one b lob)\n  (cond [(empty? lob) (cons b empty)]\n        [else\n         (if (will-sink? b (first lob))\n             (cons (first lob)\n                   (cons b              ; instead of (sink-one b (rest lob))\n                         (rest lob)))\n             (cons b lob))]))\nI changed the true answer. I only need to add the first of the list to the new b and the rest of the list instead of iterating through the entire list of blobs. The only information on the list of blobs I need is the first of the list - I only need to know if the first is a solid or a bubble to change it. By the natural recursion in the sink function, it is assumed that (rest lob) has already been \"sunk\". ",
    "instructor_answer": "Jaehwan's answer is correct.\nBut let me emphasize to OP that you were on the path to getting there as well.\nIdentifying which test is producing an incorrect result is the first step to debugging it.  Your next step would have been to figure out why sink was failing in that case.  You could use the stepper to see what is happening.  Then you would have identified a call to sink-one that wasn't producing the result it should.  Then you would have made a check-expect for sink-one that failed, and shifted your focus to sink-one.\nDebugging is hard and takes time.  The recipe sets you up for success by having you write tests.  It reduces the likelihood of error with templates.  But there's still a lot of debugging required, and part of what needs to be learned is the practice of systematically going through failing tests to identify what exactly is going wrong.  It takes a lot of patience and attention to detail."
}