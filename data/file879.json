{
    "author": "Anonymous Beaker",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 879,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/879",
    "title": "tandem worklist",
    "question": "Why we still need visited accumulator for tandem worklist ? After I saw the solution, I think it doesn't matter whether or not visited exists or not.",
    "student_answer": "t-wl is the accumulator required to make this function tail-recursive. It is a list of nodes in the tree that we have yet to visit.\np-wl is the tandem worklist that allows us to track the path from the top of the tree to the current position in the tree for each node in t-wl.\nWe use this tandem worklist to return the path taken because tail-recursive functions iterate through trees differently from structurally-recursive functions. \nStructurally-recursive functions iterate through trees like so: \nIn this tree, if we want to return the path from the top of the tree to the leaf node we're searching for, going from M1 to L1 would add \"L1\" to the end of this list. However, if L1 is not the node we're looking for, our code traverses back up the tree. This has the effect of removing visited nodes from the path when traversing back up. Essentially, going down the tree adds nodes, and going back up the tree removes nodes.\nHowever, tail-recursive functions iterate through trees like this:\nNote the lower number of red arrows. This is what makes tail-recursion more efficient! But, it also means that we can no longer benefit from travelling up the tree to remove nodes from our path. Because we go directly from L1 to M2, for example, L1 and M1 don't get removed from the path. Thus, if we don't use a tandem worklist, our function to describe the path from TOP to L2 would return (list \"TOP\" \"M1\" L1\" M2\") instead of (list \"TOP\" \"M2\" \"L2\").\nThis is where the tandem worklist (p-wl) comes in. When we start at TOP and add M1 and M2 to the t-wl, we simultaneously add the path to M1 and M2 to the p-wl. We travel down through M1, where we add L1 to the t-wl and the path to L1 to the p-wl. If L1 is the node we're looking for, we now have the path there from TOP.\nHowever, if L1 is not what we're looking for, we go to M2 and also throw away the path to it from p-wl. But, because we previously added the path to M2, we already know how to get there from TOP even though we never directly travelled from TOP to M2 like we would in structural recursion.\nWe then travel to L2, appending the path to it to the path taken to get to it from M2. Because we know a) how to get to M2 from TOP and b) how to get to L2 from M2, we now know how to travel from TOP to L2 even though our function was tail-recursive.\nDoes this make sense? I know it's a bit of a wall of text, but if you need any clarification I'm happy to help.\nEdit: yeah I totally misread the question lol sorry. Yeah, you don't need visited in this solution.",
    "instructor_answer": "The student response does a great job at explaining the accumulators that you do need. \nHowever, note that you do NOT need visited in this solution. \nYou can remove the visited accumulator and all your tests will pass.\nThat being said, next class we move on to graphs where we do need to keep track of what nodes we have already visited, so the visited accumulator becomes very important."
}