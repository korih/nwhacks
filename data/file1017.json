{
    "author": "Gregor Kiczales",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1017,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1017",
    "title": "longest-sequence 2020w1 Final",
    "question": "Hello, I was working on this problem from a previous exam and my solution differed from the official solution, could I have any feedback on whether the differences are important?\nHere's the official solution:\n(@htdf longest-sequence)\n(@signature (listof Integer) -> (listof Integer))\n;; produce the longest consecutive sequence in lon0\n\n;<examples omitted for brevity>\n\n(@template (listof Integer) accumulator)\n\n(define (longest-sequence lon0)\n  ;; curr is (listof Integer);reverse of sequence in lon0 ending just before lon\n  ;; rsf is (listof Integer) ;longest sequence found so far\n  ;; CONSTRAINT: curr will never be empty\n  (local [(define (fn-for-lon lon curr rsf)\n            (cond [(empty? lon)\n                   (if (> (length curr) (length rsf))\n                       (reverse curr)\n                       rsf)]\n                  [else\n                   (local [(define f (first lon))\n                           (define prev (first curr))]\n                     (if (= (add1 prev) f)\n                         (fn-for-lon (rest lon) (cons f curr) rsf)\n                         (fn-for-lon (rest lon) (list f)\n                                     (if (> (length curr) (length rsf))\n                                         (reverse curr)\n                                         rsf))))]))]\n  (if (empty? lon0)\n      empty\n      (fn-for-lon (rest lon0) (list (first lon0)) empty))))\nAnd here's the function definition part of mine: \n(define (longest-sequence loi0)\n  ;; last is Integer\n  ;; previous integer seen in loi0\n  ;;\n  ;; current is (listof Integer)\n  ;; current consecutive sequence seen so far\n  ;;\n  ;; best is (listof Integer)\n  ;; longest consecutive sequence seen so far\n  \n  (local [(define (fn-for-loi loi last current best)\n            (cond [(empty? loi)\n                   (if (>= (length best) (length current))\n                       (reverse best)\n                       (reverse current))]\n                  [else\n                   (cond [(= (add1 last) (first loi))\n                          (fn-for-loi (rest loi)\n                                      (first loi)\n                                      (cons (first loi) current)\n                                      best)]\n                         [(>= (length best) (length current))\n                          (fn-for-loi (rest loi)\n                                      (first loi)\n                                      (list (first loi))\n                                      best)]\n                         [else\n                          (fn-for-loi (rest loi)\n                                      (first loi)\n                                      (list (first loi))\n                                      current)])]))]\n\n    (if (empty? loi0)\n        loi0\n        (fn-for-loi (rest loi0) (first loi0) (list (first loi0)) empty))))\nNotably, I used three accumulators instead of just two, so would that be okay? Thanks!",
    "student_answer": "Not Found",
    "instructor_answer": "Good catch.  That bug has been there a while.  Fixed now. Thanks."
}