{
    "author": "Anonymous Helix",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 869,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/869",
    "title": "accumulatrs P1 - dropn (different approach didn't work)",
    "question": "Hi, I was wondering why my approach (kind of the other way around compared to the solution) to this problem didn't work...is it because I initialized the acc at 0 instead of n?  \n[EDIT]: figured it out lol, accidentally added 1 to n instead of to acc (thanks to Allison for helping me notice that at OHs!)\n(@problem 1)\n;; Design a function that consumes a list of elements lox and a natural number\n;; n and produces the list formed by dropping every nth element from lox.\n;;\n;; (dropn (list 1 2 3 4 5 6 7) 2) should produce (list 1 2 4 5 7)\n\n(@htdf dropn)\n(@signature (listof X) Natural -> (listof X))\n;; form a list by dropping every nth element from the given lox\n(check-expect (dropn empty 5) empty)\n(check-expect (dropn (list 1 2 3 4 5 6 7) 2) (list 1 2 4 5 7))\n(check-expect (dropn (list 1 2 3 4 5) 1) (list 1 3 5))\n(check-expect (dropn (list 1 2 3 4 5) 0) (list 1 2 3 4 5))\n(check-expect (dropn (list \"a\" \"b\" \"c\" \"d\" \"e\" \"f\") 2) (list \"a\" \"b\" \"d\" \"e\"))\n\n\n(@template (listof X) accumulator)\n\n(define (dropn lox0 n)\n  ;; acc is Natural; position of current element in lox0\n  ;; (dropn (list \"a\" \"b\" \"c\" \"d\") 0)\n  ;; (dropn (list     \"b\" \"c\" \"d\") 1)\n  ;; (dropn (list         \"c\" \"d\") 2) ;drop \"c\"\n  ;; (dropn (list             \"d\") 0)\n  ;; (dropn (list                ) 1)                  \n  (local [(define (fn-for-lox lox acc)\n            (cond [(empty? lox) empty]\n                  [else\n                   (if (= acc n)\n                       (fn-for-lox (rest lox) 0)\n                       (cons (first lox)\n                             (fn-for-lox (rest lox) (add1 n))))]))]\n    (fn-for-lox lox0 0))\n\n\n        Actual value (list 1 2 3 4 5 6 7) differs from (list 1 2 4 5 7), the expected value.\nin dropn-starter.rkt, line 16, column 0\n        Actual value (list 1 2 3 4 5) differs from (list 1 3 5), the expected value.\nin dropn-starter.rkt, line 17, column 0\n        Actual value '() differs from (list 1 2 3 4 5), the expected value.\nin dropn-starter.rkt, line 18, column 0\n        Actual value (list \"a\" \"b\" \"c\" \"d\" \"e\" \"f\") differs from (list \"a\" \"b\" \"d\" \"e\"), the expected value.\nin dropn-starter.rkt, line 19, column 0\nHere was the solution: \n(@htdf dropn)\n(@signature (listof X) Natural -> (listof X))\n;; produce list formed by dropping every nth element from lox\n(check-expect (dropn empty 0) empty)\n(check-expect (dropn (list \"a\" \"b\" \"c\" \"d\" \"e\" \"f\") 0) empty)\n(check-expect (dropn (list \"a\" \"b\" \"c\" \"d\" \"e\" \"f\") 1) (list \"a\" \"c\" \"e\"))\n(check-expect (dropn (list \"a\" \"b\" \"c\" \"d\" \"e\" \"f\") 2) (list \"a\" \"b\" \"d\" \"e\"))\n\n;(define (dropn lox n) empty) ;stub\n\n(@template (listof X) accumulator)\n\n(define (dropn lox0 n)\n  ;; acc: Natural; the number of elements to keep before dropping the next one\n  ;; (dropn (list \"a\" \"b\" \"c\" \"d\") 2)  ;outer call\n  ;; \n  ;; (dropn (list \"a\" \"b\" \"c\" \"d\") 2)  ; keep \n  ;; (dropn (list     \"b\" \"c\" \"d\") 1)  ; keep\n  ;; (dropn (list         \"c\" \"d\") 0)  ; drop\n  ;; (dropn (list             \"d\") 2)  ; keep\n  ;; (dropn (list                ) 1)  ; keep\n  (local [(define (dropn lox acc)\n            (cond [(empty? lox) empty]\n                  [else\n                   (if (zero? acc)\n                       (dropn (rest lox) n)\n                       (cons (first lox)\n                             (dropn (rest lox)\n                                    (sub1 acc))))]))]\n    (dropn lox0 n))) ",
    "student_answer": "You're adding 1 to n at the preservation step. Is the invariant being preserved when you add 1 to n? ",
    "instructor_answer": "Not Found"
}