{
    "author": "Jaehwan Seok",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1023,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1023",
    "title": "2019w1 problem 7",
    "question": "Official solution:\n(@htdf solve-schedule)\n(@signature (listof Class) (listof Slot) -> (listof Assign))\n;; produce schedule assigning classes to classroom slots\n\n(check-expect (solve-schedule (list C110) empty) false)\n(check-expect (solve-schedule (list C121 C210 C221 C213 C110)\n                              (list SA10 SB10 SB11 SC10 SC11))\n              (list (make-assign C110 SA10)\n                    (make-assign C213 SC10)\n                    (make-assign C221 SC11)\n                    (make-assign C210 SB10)\n                    (make-assign C121 SB11)))\n#|intentionally blank for extra space for problem 8 if needed|#\n\n;; BEFORE HANDING IN REMEMBER TO CIRCLE OPTION A, B, OR C ON PREVIOUS PAGE\n                                        \n\n(@template backtracking genrec arb-tree)\n\n(define (solve-schedule classes slots)\n  (local [(define-struct ss (classes slots assigns))\n\n          (define (solve/one ss)\n            (cond [(solved? ss) (ss-assigns ss)]\n                  [(failed? ss) false]\n                  [else\n                   (solve/lst (next-sss ss))]))\n\n          (define (solve/lst loss)\n            (cond [(empty? loss) false]\n                  [else\n                   (local [(define try1 (solve/one (first loss)))\n                           (define try2 (solve/lst (rest loss)))]\n                     (cond [(false? try1) try2]\n                           [(false? try2) try1]\n                           [else\n                            (if (< (wasted-space try1) (wasted-space try2))\n                                try1\n                                try2)]))]))\n\n          (define (next-sss ss)\n            (local [(define classes (ss-classes ss))\n                    (define slots   (ss-slots   ss))\n                    (define assigns (ss-assigns ss))]\n    \n              (map (lambda (s)\n                     (make-ss (rest classes)\n                              (remove s slots)\n                              (cons (make-assign (first classes) s) assigns)))\n                   (filter (lambda (s)\n                             (>= (slot-size s) (class-size (first classes))))\n                           slots))))\n\n\n          (define (solved? ss) (empty? (ss-classes ss)))\n          (define (failed? ss) (empty? (ss-slots  ss)))]\n\n    (solve/one (make-ss classes slots empty))))\nMy solution:\n(define (solve-schedule loc los)\n  ;; Base Case: loc is empty\n  ;; Reduction Step: each time fn-for-loa is called, one element is removed\n  ;;                 from loc\n  ;; Termination Argument: there are a finite number of classes in loc,\n  ;;                       so repeated iterations of fn-for-loa will eventually\n  ;;                       reach the base case where loc is empty\n\n  ;; acc is (listof Assign)\n  ;; list of assignments made so far\n  \n  (local [(define (fn-for-assignment loc acc)\n            (cond [(empty? loc) acc]\n                  [else\n                   (fn-for-loa (next-assignments (first loc) los)\n                               (rest loc)\n                               acc)]))\n\n          (define (fn-for-loa loa loc acc) \n            (cond [(empty? loa) false]\n                  [else\n                   (local [(define try\n                             (fn-for-assignment loc (cons (first loa) acc)))]\n                     (if (valid? (cons (first loa) acc))\n                         (if (not (false? try))\n                             try\n                             (fn-for-loa (rest loa) loc acc))\n                         (fn-for-loa (rest loa) loc acc)))]))]\n\n    (fn-for-assignment loc empty)))\n\n(@htdf next-assignments)\n(@signature Class (listof Slot) -> (listof Assign))\n;; produce all possible assignments for given class\n(@template fn-composition use-abstract-fn)\n(define (next-assignments c los)\n  (local [(define (make-assignment s)\n            (make-assign c s))\n\n          (define (enough-space? s)\n            (>= (slot-size s)\n                (class-size c)))]\n    (map make-assignment (filter enough-space? los))))\n\n(@htdf valid?)\n(@signature (listof Assign) -> Boolean)\n;; produce true if no slots are repeated in loa\n(@template (listof Assign))\n(define (valid? loa)\n  (cond [(empty? loa) true]\n        [else\n         (if (member? (assign-slot (first loa))\n                      (map assign-slot (rest loa)))\n             false\n             (valid? (rest loa)))]))",
    "student_answer": "Not Found",
    "instructor_answer": "Not Found"
}