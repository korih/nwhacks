{
    "author": "Anonymous Helix",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1026,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1026",
    "title": "Different Termination Arguments For Graphs",
    "question": "Hi,\nI've noticed different termination arguments for two graph problems that I find quite similar. \nFor one of them, the trivial case is \"reaching a node already on the path\" [2020W2F] while the other one's trivial case is having an \"empty todo list\" [2019W2F]. Also, the termination arguments I've seen in the problem set 11 solution all have a trivial case of \"reaching a treasure already visited.\" \nIs there a reason why the 2019's termination argument is based on having an empty todo list rather than reaching a node already visited? \nThank you!\nBelow are the termination arguments: \n[From 2020W2F problem 5]\n;; Termination argument: \n  ;; trivial cases: reach a node already on path\n  ;; reduction: next nodes of current node\n  ;; argument: graph is finite, so detecting cycles with path will ensure that\n  ;; we eventually visit entire graph\n\n[From 2019W2F problem 5]\n;; Termination:\n  ;;   base: todo is empty\n  ;;   reduction: if n not visited add its nexts to todo and add n to visited\n  ;;   argument:  todo grows only by nexts of n if not visited, graph is finite\n  ;;              so all nodes will eventually be visited\n\n[From Problem Set 11 Problem 6]\n;; Termination argument:\n;; trivial: reach destination or come back to treasure already on visited\n;; reduction: when reaching treasure name lookup treasure\n;; argument: graph has finite size, we don't go in circles -> will terminate\nBelow are the full solutions with the termination arguments:\n[From 2020W2F problem 5]\n(define (find-increasing-path start to)\n  ;; Termination argument:\n  ;; trivial cases: reach a node already on path\n  ;; reduction: next nodes of current node\n  ;; argument: graph is finite, so detecting cycles with path will ensure that\n  ;; we eventually visit entire graph\n  ;; \n  ;; n-wl is (listof Node): unvisited direct next nodes of the visited nodes\n  ;; path-wl is (listof (listof String)): path tandem worklist\n  ;; prev-wl is (listof Natural): previous node's number tandem worklist\n  ;;\n  ;; n-wl, path-wl and prev-wl always have same length, the elements of\n  ;; the 3 work lists correspond with each other - the nth element of\n  ;; path-wl is the path to reach the nth element of n-wl, the nth\n  ;; element in prev-wl is the number of node that occurs before the\n  ;; nth element in n-wl \n  \n  (local [(define (find/node n path prev n-wl path-wl prev-wl)\n            (cond [(string=? (node-name n) to)\n                   (reverse (cons (node-name n) path))]\n                  [(< (node-num n) prev) (find/loname n-wl path-wl prev-wl)]\n                  [else\n                   (find/loname (append (node-nexts n)\n                                        n-wl)\n                                (append (make-list (length (node-nexts n))\n                                                   (cons (node-name n) path))\n                                        path-wl)\n                                (append (make-list (length (node-nexts n))\n                                                   (node-num n))\n                                        prev-wl))]))\n          \n          (define (find/loname n-wl path-wl prev-wl)\n            (cond [(empty? n-wl) false]\n                  [else\n                   (find/name (first n-wl) (first path-wl) (first prev-wl)\n                              (rest n-wl)  (rest path-wl)  (rest prev-wl))]))\n\n          (define (find/name s path prev n-wl path-wl prev-wl)\n            (find/node (lookup-node s) path prev n-wl path-wl prev-wl))]\n    \n    (find/name start empty 0 empty empty empty)))\n[From 2019W2F problem 5]\n(define (arrows n0)\n  ;; Termination:\n  ;;   base: todo is empty\n  ;;   reduction: if n not visited add its nexts to todo and add n to visited\n  ;;   argument:  todo grows only by nexts of n if not visited, graph is finite\n  ;;              so all nodes will eventually be visited\n \n  ;; visited is (listof String): all nodes already visited\n  ;; todo is (listof String): work list\n  ;; rsf is (listof (list String Natural)) : result so far\n  (local [(define (fn-for-n n todo visited rsf)\n            (cond [(member? n visited)\n                   (fn-for-lon todo visited rsf)]\n                  [else\n                   (fn-for-lon (append (next-nodes n) todo)\n                               (cons n visited)\n                               (foldr add-arrow rsf (next-nodes n))\n                               \n                               )])) \n          (define (fn-for-lon todo visited rsf)\n            (cond [(empty? todo) rsf]\n                  [else\n                   (fn-for-n (first todo) (rest todo) visited rsf)]))\n\n          (define (add-arrow n loc)\n              (cond [(empty? loc) (list (make-count n 1))]\n                    [else\n                     (if (string=? (count-node (first loc)) n)\n                         (cons (make-count n (add1 (count-in (first loc))))\n                               (rest loc))\n                         (cons (first loc)\n                               (add-arrow n (rest loc))))]))\n          #;(define (add-arrow n loc)\n            (cond [(empty? loc) (list (make-count n 1))]\n                  [else\n                   (map (\u03bb(c) (if (string=? (count-node c) n) \n                                  (make-count n (add1 (count-in (first loc))))\n                                  c))\n                        loc)]))]\n    \n(fn-for-n n0 empty empty empty)))\n[From Problem Set 11 Problem 6]\n(define (min-route-to t s)\n  ;; trivial: reach destination or come back to treasure already on visited\n  ;; reduction: when reaching treasure name lookup treasure\n  ;; argument: graph has finite size, we don't go in circles -> will terminate\n  ;;\n  ;; \n  ;; r-wl is (listof Route)\n  ;; worklist accumulator of routes to visit\n  ;; p-wl is (listof (listof String))\n  ;; tandem worklist of paths to corresponding route on r-wl\n  ;; d-wl is (listof Natural)\n  ;; tandem work list of durations of corresponding paths\n  ;; rsf is Natural or false; duration of travel on route or false if no path\n  ;;                          found so far \n  (local [(define (fn-for-treasure t path dur r-wl p-wl d-wl rsf)\n            (cond [(member? (treasure-label t) path)\n                   (fn-for-lor r-wl p-wl d-wl rsf)]\n                  [(string=? (treasure-label t) s)\n                   (if (false? rsf)\n                       (fn-for-lor r-wl p-wl d-wl dur)\n                       (fn-for-lor r-wl p-wl d-wl (min rsf dur)))]\n                  [else (fn-for-lor (append (treasure-routes t) r-wl)\n                                    (append\n                                     (make-list (length (treasure-routes t))\n                                                (cons (treasure-label t) path))\n                                     \n                                     p-wl)\n                                    (append\n                                     (make-list (length  (treasure-routes t))\n                                                dur)\n                                     d-wl)\n                                    rsf)]))\n\n          (define (fn-for-lor r-wl p-wl d-wl rsf)\n            (cond [(empty? r-wl) rsf]\n                  [else\n                   (fn-for-route (first r-wl)\n                                 (first p-wl)\n                                 (first d-wl)\n                                 (rest r-wl)\n                                 (rest p-wl)\n                                 (rest d-wl)\n                                 rsf)]))\n\n          (define (fn-for-route r path dur r-wl p-wl d-wl rsf)\n            (fn-for-treasure (lookup-treasure (route-destination r))\n                             path\n                             (+ (route-duration r) dur)\n                             r-wl\n                             p-wl\n                             d-wl\n                             rsf))]\n    \n    (fn-for-treasure t empty 0 empty empty empty false)))",
    "student_answer": "I don't think it really matters.",
    "instructor_answer": "Not Found"
}