{
    "author": "Mina Chong",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1021,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1021",
    "title": "2020w2 question 5",
    "question": "same as posted solution (ignore visited accumulator, not actually used)\n(define (find-increasing-path start finish)\n  ;; Base case: node is one we have already visited, or node-name is finish\n  ;; Reduction step: each time we visit a node, we add it to visited\n  ;; Termination argument: there are a finite number of nodes, so eventually we\n  ;;                       will either have found finish or visited all nodes\n  ;;                       (in either case we reach the base case)\n\n  ;; node-wl is (listof String)\n  ;; primary: list of names of nodes that need to be visited\n  ;;\n  ;; path-wl is (listof (listof String))\n  ;; tandem: corresponding list of paths for each node in node-wl\n  ;;\n  ;; last-wl is (listof Natural)\n  ;; tandem: corresponding list of last node-num seen on each path in path-wl \n  ;;\n  ;; visited is (listof String)\n  ;; list of nodes already visited\n  \n  (local [(define (fn-for-node n node-wl path path-wl last last-wl visited)\n            (cond [(<= (node-num n) last)  \n                   (fn-for-los node-wl path-wl last-wl visited)]\n                  [(string=? (node-name n) finish)\n                   (reverse (cons (node-name n) path))]\n                  [else\n                   (fn-for-los (append (node-nexts n) node-wl)\n                               (append (make-list (length (node-nexts n))\n                                                  (cons (node-name n) path))\n                                       path-wl)\n                               (append (make-list (length (node-nexts n))\n                                                  (node-num n))\n                                       last-wl)\n                               (cons n visited))]))\n          \n          (define (fn-for-los node-wl path-wl last-wl visited)\n            (cond [(empty? node-wl) false]\n                  [else\n                   (fn-for-string (first node-wl) (rest node-wl)\n                                  (first path-wl) (rest path-wl)\n                                  (first last-wl) (rest last-wl)\n                                  visited)]))\n\n          (define (fn-for-string s node-wl path path-wl last last-wl visited)\n            (fn-for-node (lookup-node s)\n                         node-wl\n                         path\n                         path-wl\n                         last\n                         last-wl\n                         visited))]\n    \n    (fn-for-string start empty empty empty 0 empty empty)))\nDifferent from posted solution, visited accumulator used:\n(define (find-increasing-path start finish)\n  ;; Base case: node is one we have already visited, or node-name is finish\n  ;; Reduction step: each time we visit a node, we add it to visited\n  ;; Termination argument: there are a finite number of nodes, so eventually we\n  ;;                       will either have found finish or visited all nodes\n  ;;                       (in either case we reach the base case)\n\n  ;; node-wl is (listof String)\n  ;; primary: list of names of nodes that need to be visited\n  ;;\n  ;; path-wl is (listof (listof String))\n  ;; tandem: corresponding list of paths for each node in node-wl\n  ;;\n  ;; last-wl is (listof Natural)\n  ;; tandem: corresponding list of last node-num seen on each path in path-wl \n  ;;\n  ;; visited is (listof String)\n  ;; list of nodes already visited\n  \n  (local [(define (fn-for-node n node-wl path path-wl last last-wl visited)\n            (cond [(member? n visited)  \n                   (fn-for-los node-wl path-wl last-wl visited)]\n                  [(string=? (node-name n) finish)\n                   (reverse (cons (node-name n) path))]\n                  [(> (node-num n) last)\n                   (fn-for-los (append (node-nexts n) node-wl)\n                               (append (make-list (length (node-nexts n))\n                                                  (cons (node-name n) path))\n                                       path-wl)\n                               (append (make-list (length (node-nexts n))\n                                                  (node-num n))\n                                       last-wl)\n                               (cons n visited))]\n                  [else\n                   (fn-for-los node-wl path-wl last-wl visited)]))\n          \n          (define (fn-for-los node-wl path-wl last-wl visited)\n            (cond [(empty? node-wl) false]\n                  [else\n                   (fn-for-string (first node-wl) (rest node-wl)\n                                  (first path-wl) (rest path-wl)\n                                  (first last-wl) (rest last-wl)\n                                  visited)]))\n\n          (define (fn-for-string s node-wl path path-wl last last-wl visited)\n            (fn-for-node (lookup-node s)\n                         node-wl\n                         path\n                         path-wl\n                         last\n                         last-wl\n                         visited))]\n    \n    (fn-for-string start empty empty empty 0 empty empty)))",
    "student_answer": "^ answered in office hours, second solution (using the visited accumulator) is incorrect because we could potentially have the function produce a decreasing path",
    "instructor_answer": "Not Found"
}