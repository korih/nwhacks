{
    "author": "Anonymous Scale",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 821,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/821",
    "title": "Backtracking in MT2 P2",
    "question": "I've been working to understand the various reasons I lost marks in P2.  At this point I understand almost everywhere I went wrong, except for one aspect of my backtracking implementation.\nI'm including my code here to publicly embarrass myself facilitate the learning process for myself and others.\nFirst the basics: I missed a small but important part of the math for calculating grant value.  I also didn't include the right check-expects to catch that, because I wrote them based on my misunderstanding of the math.  Those mistakes were straightforward, so to focus on the part I don't fully understand, I also pasted a version of my code with corrected math and check-expects (bottom).\nNext I implemented \"(if (not (false? x)) x lox)\" for backtracking.  Sounds good except that I didn't use a local \"try\" and therefore my approach didn't reduce recomputation.  In a big tree that'd be a big problem.\nI'm wondering: is try-catch primarily about reducing recomputation or about backtracking?  Or both?  I lost marks for not including try-catch in the employee and loe functions, though I think my approach was at least valid for backtracking.\nMy submitted MT2 P2 code:\n(@htdf find-grant-with-value) ;uncomment when you start\n(@signature Employee Natural Natural Natural -> Grant or false)\n;; search tree for grant with given value\n(check-expect (find-grant-with-value E8 50 500 4000) G17)\n(check-expect (find-grant-with-value E8 40 365 5000) G11)\n(check-expect (find-grant-with-value E8 41 365 5000) G11)\n(check-expect (find-grant-with-value E8 40 364 5000) false)\n\n  (@template Employee ListOfEmployee ListOfGrant Grant\n             encapsulated try-catch)\n  \n  (define (find-grant-with-value e sp dn da)\n    (local [(define (c1 n h loe log) (if (not (false? log)) log loe))\n            (define (c3 g log) (if (not (false? g)) g log))\n            (define (c2 e loe) (if (not (false? e)) e loe))\n            (define (c4 s p v) (if (and (>= dn v) (>= (* p s) da))\n                                   (make-grant s p v)\n                                   false))\n\n            (define (fn-for-employee e)\n              (c1 (emp-name e)\n                  (emp-hired e)\n                  (fn-for-loe (emp-reports e))\n                  (fn-for-log (emp-grants e))))\n\n            (define (fn-for-loe loe)\n              (cond [(empty? loe) false]\n                    [else\n                     (c2 (fn-for-employee (first loe))\n                         (fn-for-loe (rest loe)))]))\n\n            (define (fn-for-log log)\n              (cond [(empty? log) false]\n                    [else\n                     (c3 (fn-for-grant (first log))\n                         (fn-for-log (rest log)))]))\n\n            (define (fn-for-grant g)\n              (c4 (grant-shares g)\n                  (grant-price g)\n                  (grant-vests g)))]\n    \n      (fn-for-employee e)))\nMy code but with two changes: 1) corrected math for grant value in c4 and 2) using all check-expects from the solution file (which all pass using corrected math):\n(@htdf find-grant-with-value) ;uncomment when you start\n(@signature Employee Natural Natural Natural -> Grant or false)\n;; search tree for grant with given value\n(check-expect (find-grant-with-value E8  50 364  2000) false)\n(check-expect (find-grant-with-value E8  50 365  2000) G17)   ;(mg  500 40 365)\n(check-expect (find-grant-with-value E8  50 366  2000) G17)   ;(mg  500 40 365)\n(check-expect (find-grant-with-value E8  50 500  4000) G17)   ;(mg  500 40 365)\n(check-expect (find-grant-with-value E1  60 365 09999) G11)   ;(mg  500 40 365)\n(check-expect (find-grant-with-value E1  60 365 10000) G11)   ;(mg  500 40 365)\n(check-expect (find-grant-with-value E1  60 365 10001) false)\n(check-expect (find-grant-with-value E1  50 730 10000) G18)   ;(mg 1000 40 730)\n\n  (@template Employee ListOfEmployee ListOfGrant Grant\n             encapsulated try-catch)\n  \n  (define (find-grant-with-value e sp dn da)\n    (local [(define (c1 n h loe log) (if (not (false? log)) log loe))\n            (define (c3 g log) (if (not (false? g)) g log))\n            (define (c2 e loe) (if (not (false? e)) e loe))\n            (define (c4 s p v) (if (and (>= dn v) (>= (* (- sp p) s) da))\n                                   (make-grant s p v)\n                                   false))\n\n            (define (fn-for-employee e)\n              (c1 (emp-name e)\n                  (emp-hired e)\n                  (fn-for-loe (emp-reports e))\n                  (fn-for-log (emp-grants e))))\n\n            (define (fn-for-loe loe)\n              (cond [(empty? loe) false]\n                    [else\n                     (c2 (fn-for-employee (first loe))\n                         (fn-for-loe (rest loe)))]))\n\n            (define (fn-for-log log)\n              (cond [(empty? log) false]\n                    [else\n                     (c3 (fn-for-grant (first log))\n                         (fn-for-log (rest log)))]))\n\n            (define (fn-for-grant g)\n              (c4 (grant-shares g)\n                  (grant-price g)\n                  (grant-vests g)))]\n    \n      (fn-for-employee e)))",
    "student_answer": "Not Found",
    "instructor_answer": "Part of the issue here is that problem 2 wanted you to use the templates and not the fold function.  The reason it did so is that a key property of backtracking search is to stop traversing the tree as soon as the search gets to the item it is looking for.  But fold functions always traverse the whole tree.  So they are not appropriate for doing a backtracking search.\nYou can see some of this in your c1.  Note that the normal use of try catch looks something like:\n(local [(define try (call-some-mr-function (first lox)))]\n  (if (not (false? try))\n      try\n      (call-same-function-as-natural-recursion (rest lox))))\nBut in your c1 you write:\n(define (c1 n h loe log) (if (not (false? log)) log loe)\nNotice that the normal use of try catch prevents the natural recursion from being evaluates if the first branch succeeds. But by the time the fold function calls c1, both the mutual and natural recursions have already been evaluated.  c1 is called with the RESULTS of those evaluations.  So it can choose which result to use, but it can't cut the search off if the first branch succeeds -- the children have all already been searched."
}