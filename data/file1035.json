{
    "author": "Anonymous Beaker",
    "position": "student",
    "course": "CPSC 110 2021WT2",
    "post_num": 1035,
    "link": "https://piazza.com/class/ky0ewiregcz421/post/1035",
    "title": "Backtracking template tag in 2020W1-F-p6 (nqueens)",
    "question": "In the solution for 2020W1-F-p6 (nqueens), I noticed that the \"backtracking\" tag replaced the \"try-catch\" tag when the function was revised to produce the number of boards it searched instead of the solved board:\n(@template encapsulated backtracking genrec arb-tree accumulator)\n\n(define (nqueens N)          \n  ;; Termination argument:\n  ;; Trivial cases:\n  ;;   bd is solved or it is impossible to add a queen and get a valid board\n  ;; \n  ;; Reduction step:\n  ;;   add a queen at every possible empty position (after last queen)\n  ;; \n  ;; Since board is finite, and each board is explored at most once, \n  ;; search will definitely terminate. (But the search space does grow\n  ;; really fast!)\n  \n  (local [\n          #;#;\n          ;; Board -> Board or false\n          (define (fn-for-bd bd)\n            (cond [(solved? bd) bd]\n                  [else\n                   (fn-for-lobd (next-boards bd))]))\n\n          ;; (listof Board) -> Board or false\n          (define (fn-for-lobd lobd)\n            (cond [(empty? lobd) false]\n                  [else\n                   (local [(define try (fn-for-bd (first lobd)))]\n                     (if (not (false? try))\n                         try\n                         (fn-for-lobd (rest lobd))))]))\n          \n          ;; bd-wl is (listof Board); worklist\n   ;; v-count is Natural; number of Boards considered so far\n          ;; Board -> Natural or false\n          (define (fn-for-bd bd bd-wl v-count)\n            (cond [(solved? bd) (add1 v-count)]\n                  [else\n                   (fn-for-lobd (append (next-boards bd) bd-wl)\n                                (add1 v-count))]))\n          \n          ;; (listof Board) -> Natural or false\n          (define (fn-for-lobd bd-wl v-count)\n            (cond [(empty? bd-wl) false]\n                  [else\n                   (fn-for-bd (first bd-wl) (rest bd-wl) v-count)]))\n          \n          \n          ;; Board -> Boolean\n          ;; Produce true if board has N queens.\n          (define (solved? bd) (= (length bd) N))\n\n\n          ;; Board -> (listof Board)\n          ;; produce next valid boards by adding a queen at every new position \n          ;;   - that comes after all existing queen positions (not required)\n          ;;   - that does not attack any existing queens\n          ;; (@template fn-composition use-abstract-fn)\n          (define (next-boards bd)\n            (local [(define max-so-far (foldr max -1 bd))] ;highest queen pos\n              (map (lambda (p2) (cons p2 bd)) \n                   (filter (lambda (p2)\n                             (and (> p2 max-so-far)\n                                  (andmap (lambda (p1)     \n                                            (not (attack? p2 p1)))\n                                          bd)))\n                           (build-list (sqr N) identity)))))\n          \n          ;; Position Position -> Boolean\n          ;; produce true if queens at position a and b attack each other\n          (define (attack? pa pb)\n            (local [(define x1 (pos-x pa))\n                    (define y1 (pos-y pa))\n                    (define x2 (pos-x pb))\n                    (define y2 (pos-y pb))]\n              (or (= x1 x2)                           ;same row\n                  (= y1 y2)                           ;same column\n                  (= (/ (- y2 y1) (- x2 x1))  1)      ;same slope  1 diagonal\n                  (= (/ (- y2 y1) (- x2 x1)) -1))))   ;same slope -1 diagonal\n          \n          \n          ;; Pos -> Natural\n          ;; produce the row or column number in [0, N) for the given position\n          (define (pos-x p) (remainder p N))\n          (define (pos-y p) (quotient  p N))]\n    \n    (fn-for-bd empty empty 0)))\nHowever, as far as I'm aware, we've stopped using the backtracking template tag. So, if we were given a try-catch function to repurpose and made it tail-recursive (getting rid of (not (false? try)) in the process), we would only get rid of the try-catch template tag and not add backtracking, right?",
    "student_answer": "Not Found",
    "instructor_answer": "Yes.\nThanks for pointing this out. Fixed now."
}